#include<iostream>
using namespace std;

int dp[(1<<20)+1];//dp数组 
int n,m,k,a[101]; 
//状态压缩动态规划（简称状压dp）是另一类非常典型的动态规划，通常使用在NP问题的小规模求解中，虽然是指数级别的复杂度
//该算法主要以二进制的方式 思维 
//入门：https://www.cnblogs.com/ibilllee/p/7651971.html   https://zhuanlan.zhihu.com/p/131585177

int main()
{
    fill(dp,dp+(1<<20)+1,0xffff);//初始化 dp数组 
    cin >> n >> m >> k;//输入 
    int c[m];//占位数组 有则是1 无为0 
    
    fill(c,c+m,0);//用来鉴定是否能全尝到 s
    bool NUL=false;//用来鉴定是否能全尝到 
    
    for(int i=1;i<=n;++i)//有n包 
    {
        int x=0,y;
        for(int j=1;j<=k;++j)//每包中的 类型 
        {
            //比如有5类糖果即5位 二进制0表示没有 1表示有 如果某一组是有 1(1<<1-1=00001) 3(1<<3-1=00100) 4(1<<4-1=01000) 糖果
            //然后这一组进行 ‘|’ 或运算  然后就可以表示这一组就是 01101 然后这个数字十进制13就可以表示这个 这一包的种类
            cin >> y; 
            y--;//上面有过程 解释 
            x|=(1<<y);//或运算是在(十进制也是在二进制中)二进制中 0|1=1 0|0=0 1|1=1 1<<v相当于乘v个2 //根据二进制可以知道有几种糖果
            
            c[y]++; //先检验糖果是否全 只和鉴定是否能全得到有关 
        }
        a[i]=x;//将每一包所有的种类给它 
    }
    for(int i=0;i<m;i++)//用来鉴定是否能全尝到 
    if(!c[i])NUL=true;//用来鉴定是否能全尝到 
    if(NUL)cout <<"-1";//糖果种类不全打印-1 
    else{
        dp[0]=0;//初始化 当然下面这个肯定从这里开始的 
        for(int i=1;i<=n;i++)
        {
            // (1<<m)-1 - > length(1<<n-1) = n = n个(1) - > (1<<m)-1的意义 
            for(int j=(1<<m)-1;j>=0;--j)//
            dp[j|a[i]]=min(dp[j|a[i]],dp[j]+1);//从第一包开始  
            /** 解释：： 
            dp[j|a[i]] 表示在所有糖果类中的 j|a[i] 类中的 最优解
            ① 当j=0 时  j|a[i]=a[i] dp[a[i]]=1;
            ② 当j=a[i1] 时 dp[[j|a[i2]] 就是 a[i1]与a[i2] 并集的 最优解
            ③ 进一步向上迭代 直至完全 
            ④ 当计算出j|a[i]=(1)n 时（进制全为一 ） 即包含所有种类 这个就是最终解 
            */ 
        }
        cout << dp[(1<<m)-1];//打印最终解 
    }  
    return 0;
} 